package trieimport (	"sync")// Trie Treetype Trie struct {	Root  *Node	Mutex sync.RWMutex}type KV struct {	Key string	Val interface{}}// Node Trie tree nodetype Node struct {	subs map[rune]*Node	end  bool	kv   KV}// NewTrie returns a Trie treefunc NewTrie() *Trie {	t := new(Trie)	t.Root = NewTrieNode()	return t}// NewTrieNode return a *TrieNodefunc NewTrieNode() *Node {	n := new(Node)	n.subs = make(map[rune]*Node)	n.end = false	//n.val = nil	return n}// 插入一个敏感词(UTF-8的)到Trie树中,不覆盖valfunc (t *Trie) Insert(keyword string, val interface{}) (setv interface{}) {	node := t.add(keyword, val, false)	if node != nil {		return node.kv.Val	}	return nil}// 更新一个敏感词(UTF-8的)到Trie树中,覆盖valfunc (t *Trie) Upsert(keyword string, val interface{}) {	t.add(keyword, val, true)}func (t *Trie) add(keyword string, val interface{}, cover bool) *Node {	chars := []rune(keyword)	if len(chars) == 0 {		return nil	}	t.Mutex.Lock()	node := t.Root	for _, char := range chars {		if _, ok := node.subs[char]; !ok {			node.subs[char] = NewTrieNode()		}		node = node.subs[char]	}	node.end = true	node.kv.Key = keyword	if cover || node.kv.Val == nil {		node.kv.Val = val	}	t.Mutex.Unlock()	return node}// Del 从Trie树中删除一个敏感词func (t *Trie) Delete(keyword string) {	chars := []rune(keyword)	if len(chars) == 0 {		return	}	t.Mutex.Lock()	node := t.Root	t.cycleDel(node, chars, 0)	t.Mutex.Unlock()}func (t *Trie) cycleDel(node *Node, chars []rune, index int) (shouldDel bool) {	char := chars[index]	l := len(chars)	if n, ok := node.subs[char]; ok {		if index+1 < l {			shouldDel = t.cycleDel(n, chars, index+1)			if shouldDel && len(n.subs) == 0 {				if n.end { // 说明这是一个敏感词，不能删除					shouldDel = false				} else {					delete(node.subs, char)				}			}		} else if n.end {			if len(n.subs) == 0 { // 是最后一个节点				shouldDel = true				delete(node.subs, char)			} else { // 不是最后一个节点				n.end = false			}		}	}	return}func (t *Trie) Get(text string) (v interface{}, ok bool) {	kv := t.PrefixQueryLongest(text)	if kv != nil && kv.Key == text {		return kv.Val, true	}	return nil, false}func (t *Trie) All() (kvs []*KV) {	t.Mutex.Lock()	kvs = t.all(t.Root, kvs)	t.Mutex.Unlock()	return kvs}func (t *Trie) all(node *Node, kvs []*KV) []*KV {	for _, n := range node.subs {		if n.end {			kvs = append(kvs, &n.kv)		}		if len(n.subs) > 0 {			kvs = t.all(n, kvs)		}	}	return kvs}//查询最长的前缀匹配func (t *Trie) PrefixQueryLongest(text string) (kv *KV) {	chars := []rune(text)	l := len(chars)	if l == 0 {		return nil	}	t.Mutex.RLock()	defer t.Mutex.RUnlock()	return t.prefixQueryLongest(t.Root, chars)}func (t *Trie) prefixQueryLongest(node *Node, chars []rune) (kv *KV) {	l := len(chars)	if l == 0 {		return nil	}	char := chars[0]	if n, ok := node.subs[char]; ok {		if n.end {			kv = &n.kv		}		skv := t.prefixQueryLongest(n, chars[1:])		if skv != nil {			return skv		}	}	return kv}//查询全部匹配的前缀关键词func (t *Trie) PrefixQuery(text string) (kvs []*KV) {	chars := []rune(text)	l := len(chars)	if l == 0 {		return nil	}	t.Mutex.RLock()	defer t.Mutex.RUnlock()	return t.prefixQuery(t.Root, chars, kvs, func(*KV) bool {		return true	})}func (t *Trie) PrefixQueryFunc(text string, f func(*KV) bool) (kvs []*KV) {	chars := []rune(text)	l := len(chars)	if l == 0 {		return nil	}	t.Mutex.RLock()	defer t.Mutex.RUnlock()	return t.prefixQuery(t.Root, chars, kvs, f)}func (t *Trie) prefixQuery(node *Node, chars []rune, kvs []*KV, f func(*KV) bool) []*KV {	l := len(chars)	if l == 0 {		return nil	}	char := chars[0]	if n, ok := node.subs[char]; ok {		if n.end && f(&n.kv) {			kvs = append(kvs, &n.kv)		}		kvs = t.prefixQuery(n, chars[1:], kvs, f)	}	return kvs}